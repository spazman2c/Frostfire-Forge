searchState.loadedDescShard("ethnum", 0, "This crate implements 256-bit integer types.\nThis trait defines <code>as</code> conversions (casting) from primitive …\nThis trait defines <code>as</code> conversions (casting) from primitive …\nThe size of this integer type in bits.\nThe size of this integer type in bits.\nA 256-bit signed integer type.\nThe largest value that can be represented by this integer …\nThe largest value that can be represented by this integer …\nThe smallest value that can be represented by this integer …\nThe smallest value that can be represented by this integer …\nThe multiplicative inverse for this integer type, i.e. <code>-1</code>.\nThe multiplicative identity for this integer type, i.e. <code>1</code>.\nThe multiplicative identity for this integer type, i.e. <code>1</code>.\nA 256-bit unsigned integer type.\nThe additive identity for this integer type, i.e. <code>0</code>.\nThe additive identity for this integer type, i.e. <code>0</code>.\nComputes the absolute value of <code>self</code>.\nComputes the absolute difference between <code>self</code> and <code>other</code>.\nComputes the absolute difference between <code>self</code> and <code>other</code>.\nCast to a primitive <code>f32</code>.\nCast to a primitive <code>f32</code>.\nCast to a primitive <code>f64</code>.\nCast to a primitive <code>f64</code>.\nCast to a primitive <code>i128</code>.\nCast to a primitive <code>i128</code>.\nCast to a primitive <code>i16</code>.\nCast to a primitive <code>i16</code>.\nPerform an <code>as</code> conversion to a <code>I256</code>.\nCast to a <code>I256</code>.\nCast to a primitive <code>i32</code>.\nCast to a primitive <code>i32</code>.\nCast to a primitive <code>i64</code>.\nCast to a primitive <code>i64</code>.\nCast to a primitive <code>i8</code>.\nCast to a primitive <code>i8</code>.\nCast to a primitive <code>isize</code>.\nCast to a primitive <code>isize</code>.\nCast to a primitive <code>u128</code>.\nCast to a primitive <code>u128</code>.\nCast to a primitive <code>u16</code>.\nCast to a primitive <code>u16</code>.\nPerform an <code>as</code> conversion to a <code>U256</code>.\nCast to a <code>U256</code>.\nCast to a primitive <code>u32</code>.\nCast to a primitive <code>u32</code>.\nCast to a primitive <code>u64</code>.\nCast to a primitive <code>u64</code>.\nCast to a primitive <code>u8</code>.\nCast to a primitive <code>u8</code>.\nCast to a primitive <code>usize</code>.\nCast to a primitive <code>usize</code>.\nChecked absolute value. Computes <code>self.abs()</code>, returning <code>None</code>…\nChecked integer addition. Computes <code>self + rhs</code>, returning …\nChecked integer addition. Computes <code>self + rhs</code>, returning …\nChecked addition with a signed integer. Computes <code>self + rhs</code>…\nChecked addition with an unsigned integer. Computes …\nChecked integer division. Computes <code>self / rhs</code>, returning …\nChecked integer division. Computes <code>self / rhs</code>, returning …\nChecked Euclidean division. Computes <code>self.div_euclid(rhs)</code>, …\nChecked Euclidean division. Computes <code>self.div_euclid(rhs)</code>, …\nChecked division. Computes <code>self.div_rem(rhs)</code>, returning …\nChecked integer division. Computes <code>self.div_rem(rhs)</code>, …\nChecked Euclidean division. Computes …\nChecked Euclidean division. Computes …\nChecked integer multiplication. Computes <code>self * rhs</code>, …\nChecked integer multiplication. Computes <code>self * rhs</code>, …\nChecked negation. Computes <code>-self</code>, returning <code>None</code> if …\nChecked negation. Computes <code>-self</code>, returning <code>None</code> unless …\nReturns the smallest power of two greater than or equal to …\nChecked exponentiation. Computes <code>self.pow(exp)</code>, returning …\nChecked exponentiation. Computes <code>self.pow(exp)</code>, returning …\nChecked integer remainder. Computes <code>self % rhs</code>, returning …\nChecked integer remainder. Computes <code>self % rhs</code>, returning …\nChecked Euclidean remainder. Computes <code>self.rem_euclid(rhs)</code>…\nChecked Euclidean modulo. Computes <code>self.rem_euclid(rhs)</code>, …\nChecked shift left. Computes <code>self &lt;&lt; rhs</code>, returning <code>None</code> …\nChecked shift left. Computes <code>self &lt;&lt; rhs</code>, returning <code>None</code> …\nChecked shift right. Computes <code>self &gt;&gt; rhs</code>, returning <code>None</code> …\nChecked shift right. Computes <code>self &gt;&gt; rhs</code>, returning <code>None</code> …\nChecked integer subtraction. Computes <code>self - rhs</code>, …\nChecked integer subtraction. Computes <code>self - rhs</code>, …\nChecked subtraction with an unsigned integer. Computes …\nReturns the number of ones in the binary representation of …\nReturns the number of ones in the binary representation of …\nReturns the number of zeros in the binary representation …\nReturns the number of zeros in the binary representation …\nCalculates the quotient of Euclidean division of <code>self</code> by …\nPerforms Euclidean division.\nPerforms integer and division and returns the quotient and …\nPerforms integer and division and returns the quotient and …\nPerforms euclidean division and returns the quotient and …\nPerforms Euclidean division.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConverts an integer from big endian to the target’s …\nConverts an integer from big endian to the target’s …\nCreate an integer value from its representation as a byte …\nCreate an integer value from its representation as a byte …\nConverts an integer from little endian to the target’s …\nConverts an integer from little endian to the target’s …\nCreate an integer value from its representation as a byte …\nCreate an integer value from its representation as a byte …\nCreate an integer value from its memory representation as …\nCreate an integer value from its memory representation as …\nConverts a prefixed string slice in base 16 to an integer.\nConverts a prefixed string slice in base 16 to an integer.\nConverts a prefixed string slice in a base determined by …\nConverts a prefixed string slice in a base determined by …\nConverts a string slice in a given base to an integer.\nConverts a string slice in a given base to an integer.\nCreates a new 256-bit integer value from high and low …\nCreates a new 256-bit integer value from high and low …\nGet the high 128-bit word for this signed integer.\nGet the high 128-bit word for this unsigned integer.\nGet the high 128-bit word for this signed integer as a …\nGet the high 128-bit word for this unsigned integer as a …\nA 256-bit signed integer type.\nMacro for 256-bit signed integer literal.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSplits a 256-bit integer into high and low words.\nSplits a 256-bit integer into high and low words.\nThis module contains intrinsics used by the <code>I256</code> and <code>U256</code> …\nReturns <code>true</code> if <code>self</code> is negative and <code>false</code> if the number …\nReturns <code>true</code> if <code>self</code> is positive and <code>false</code> if the number …\nReturns <code>true</code> if and only if <code>self == 2^k</code> for some <code>k</code>.\nReturns the number of leading ones in the binary …\nReturns the number of leading ones in the binary …\nReturns the number of leading zeros in the binary …\nReturns the number of leading zeros in the binary …\nGet the low 128-bit word for this signed integer.\nGet the low 128-bit word for this unsigned integer.\nGet the low 128-bit word for this signed integer as a …\nGet the low 128-bit word for this unsigned integer as a …\nCreates a new 256-bit integer value from a primitive <code>i128</code> …\nCreates a new 256-bit integer value from a primitive <code>u128</code> …\nReturns the smallest power of two greater than or equal to …\nComputes the absolute value of <code>self</code>.\nCalculates <code>self</code> + <code>rhs</code>\nCalculates <code>self</code> + <code>rhs</code>\nCalculates <code>self</code> + <code>rhs</code> with a signed <code>rhs</code>\nCalculates <code>self</code> + <code>rhs</code> with an unsigned <code>rhs</code>\nCalculates the divisor when <code>self</code> is divided by <code>rhs</code>.\nCalculates the divisor when <code>self</code> is divided by <code>rhs</code>.\nCalculates the quotient of Euclidean division …\nCalculates the quotient of Euclidean division …\nCalculates the quotient and the remainder when <code>self</code> is …\nCalculates the quotient and the remainder when <code>self</code> is …\nCalculates the quotient and remainder of Euclidean …\nCalculates the quotient of Euclidean division …\nCalculates the multiplication of <code>self</code> and <code>rhs</code>.\nCalculates the multiplication of <code>self</code> and <code>rhs</code>.\nNegates self, overflowing if this is equal to the minimum …\nNegates self in an overflowing fashion.\nRaises self to the power of <code>exp</code>, using exponentiation by …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nCalculates the remainder when <code>self</code> is divided by <code>rhs</code>.\nCalculates the remainder when <code>self</code> is divided by <code>rhs</code>.\nOverflowing Euclidean remainder. Calculates …\nCalculates the remainder <code>self.rem_euclid(rhs)</code> as if by …\nShifts self left by <code>rhs</code> bits.\nShifts self left by <code>rhs</code> bits.\nShifts self right by <code>rhs</code> bits.\nShifts self right by <code>rhs</code> bits.\nCalculates <code>self</code> - <code>rhs</code>\nCalculates <code>self</code> - <code>rhs</code>\nCalculates <code>self</code> - <code>rhs</code> with an unsigned <code>rhs</code>\nRaises self to the power of <code>exp</code>, using exponentiation by …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nConvenience re-export of 256-integer types and as- …\nCalculates the least nonnegative remainder of …\nCalculates the least remainder of <code>self (mod rhs)</code>.\nReverses the order of bits in the integer. The least …\nReverses the bit pattern of the integer.\nShifts the bits to the left by a specified amount, <code>n</code>, …\nShifts the bits to the left by a specified amount, <code>n</code>, …\nShifts the bits to the right by a specified amount, <code>n</code>, …\nShifts the bits to the right by a specified amount, <code>n</code>, …\nSaturating absolute value. Computes <code>self.abs()</code>, returning …\nSaturating integer addition. Computes <code>self + rhs</code>, …\nSaturating integer addition. Computes <code>self + rhs</code>, …\nSaturating addition with a signed integer. Computes …\nSaturating addition with an unsigned integer. Computes …\nSaturating integer division. Computes <code>self / rhs</code>, …\nSaturating integer division. Computes <code>self / rhs</code>, …\nSaturating integer division. Computes <code>self.div_rem(rhs)</code>, …\nSaturating integer division. Computes <code>self.div_rem(rhs)</code>, …\nSaturating integer division. Computes …\nSaturating integer division. Computes …\nSaturating integer multiplication. Computes <code>self * rhs</code>, …\nSaturating integer multiplication. Computes <code>self * rhs</code>, …\nSaturating integer negation. Computes <code>-self</code>, returning <code>MAX</code> …\nSaturating integer exponentiation. Computes <code>self.pow(exp)</code>, …\nSaturating integer exponentiation. Computes <code>self.pow(exp)</code>, …\nSaturating integer subtraction. Computes <code>self - rhs</code>, …\nSaturating integer subtraction. Computes <code>self - rhs</code>, …\nSaturating subtraction with an unsigned integer. Computes …\nSerde serialization implementation for 256-bit integer …\nReturns a number representing sign of <code>self</code>.\nReturns a number representing sign of <code>self</code> as a 128 bit …\nReverses the byte order of the integer.\nReverses the byte order of the integer.\nConverts <code>self</code> to big endian from the target’s endianness.\nConverts <code>self</code> to big endian from the target’s endianness.\nReturn the memory representation of this integer as a byte …\nReturn the memory representation of this integer as a byte …\nConverts <code>self</code> to little endian from the target’s …\nConverts <code>self</code> to little endian from the target’s …\nReturn the memory representation of this integer as a byte …\nReturn the memory representation of this integer as a byte …\nReturn the memory representation of this integer as a byte …\nReturn the memory representation of this integer as a byte …\nReturns the number of trailing ones in the binary …\nReturns the number of trailing ones in the binary …\nReturns the number of trailing zeros in the binary …\nReturns the number of trailing zeros in the binary …\nA 256-bit unsigned integer type.\nMacro for 256-bit unsigned integer literal.\nComputes the absolute value of <code>self</code> without any wrapping …\nWrapping (modular) absolute value. Computes <code>self.abs()</code>, …\nWrapping (modular) addition. Computes <code>self + rhs</code>, wrapping …\nWrapping (modular) addition. Computes <code>self + rhs</code>, wrapping …\nWrapping (modular) addition with a signed integer. Computes\nWrapping (modular) addition with an unsigned integer. …\nWrapping (modular) division. Computes <code>self / rhs</code>, wrapping …\nWrapping (modular) division. Computes <code>self / rhs</code>. Wrapped …\nWrapping Euclidean division. Computes <code>self.div_euclid(rhs)</code>,\nWrapping Euclidean division. Computes <code>self.div_euclid(rhs)</code>…\nPerforms integer and division and returns the quotient and …\nWrapping (modular) division. Computes <code>self.div_rem(rhs)</code>. …\nPerforms euclidean division and returns the quotient and …\nWrapping Euclidean division. Computes …\nWrapping (modular) multiplication. Computes <code>self * rhs</code>, …\nWrapping (modular) multiplication. Computes <code>self * rhs</code>, …\nWrapping (modular) negation. Computes <code>-self</code>, wrapping …\nWrapping (modular) negation. Computes <code>-self</code>, wrapping …\nWrapping (modular) exponentiation. Computes <code>self.pow(exp)</code>, …\nWrapping (modular) exponentiation. Computes <code>self.pow(exp)</code>, …\nWrapping (modular) remainder. Computes <code>self % rhs</code>, …\nWrapping (modular) remainder. Computes <code>self % rhs</code>. Wrapped …\nWrapping Euclidean remainder. Computes <code>self.rem_euclid(rhs)</code>…\nWrapping Euclidean modulo. Computes <code>self.rem_euclid(rhs)</code>. …\nPanic-free bitwise shift-left; yields <code>self &lt;&lt; mask(rhs)</code>, …\nPanic-free bitwise shift-left; yields <code>self &lt;&lt; mask(rhs)</code>, …\nPanic-free bitwise shift-right; yields <code>self &gt;&gt; mask(rhs)</code>, …\nPanic-free bitwise shift-right; yields <code>self &gt;&gt; mask(rhs)</code>, …\nWrapping (modular) subtraction. Computes <code>self - rhs</code>, …\nWrapping (modular) subtraction. Computes <code>self - rhs</code>, …\nWrapping (modular) subtraction with an unsigned integer. …\nModule containing signed wrapping functions around various …\nSerde byte serialization for 256-bit integer types.\nSerde compressed byte serialization for 256-bit integer …\nModule for use with …\nModule for use with …\nModule for use with …\nModule for use with …\nModule for use with …\nModule for use with …\nModule for …\nModule for …\nModule for …")